# Preface
Recently, the Microsoft Threat Intelligence Team exposed the use of SysAid by the DEV-0950 (Lace Tempest) group. Subsequently, the SysAid security team quickly launched an emergency response to deal with the organization's attack methods. However, no detailed explanation was provided during the analysis and reproduction of the vulnerability. Since the product requires a license when installed, it increases the difficulty of debugging vulnerabilities on the fly. In order to facilitate debugging and quickly reproduce the vulnerability, we tried to simulate the main logic flow of the vulnerability by using only part of the unit code for dynamic debugging analysis. In the end, we successfully exploited this vulnerability using the Goby tool.


![](https://s3.bmp.ovh/imgs/2023/11/15/105d49cb7220f659.gif)

# Patch analysis
The announcement published in SysAid states that the vulnerability was fixed in 23.3.36. Through the Diff patch, it was found that the repair method was mainly completed by restricting `..` in the `com.ilient.server.UserEntry#doPost` function.
![](https://s3.bmp.ovh/imgs/2023/11/16/61fe29bb5d230040.png)

# Unit debugging
Since the installation package restricts the license during installation, installation and debugging cannot be performed effectively. In order to enable efficient dynamic debugging, we adopted the following optimization strategy: create an independent empty project and rewrite the vulnerable Servlet for unit simulation. Through this method, we can minimize the vulnerability point without any dependencies and successfully complete the research and analysis work.

It can be inferred from the repair method that the vulnerability is exploited by specifying the upload path (`accountId` parameter) and upload content through directory traversal.
![](https://s3.bmp.ovh/imgs/2023/11/16/65683ef3606bfded.png)

After receiving the `accountId` parameter value, the path will be spliced through the `a` function. Due to certain problems in this splicing method, directory traversal will occur, and then the incoming data stream will be written to `accountId` Controllable path.
![](https://s3.bmp.ovh/imgs/2023/11/16/54aa3ac8e4412169.png)

After writing is completed, call `a(var31, var46, var7);` to complete the decompression of the incoming data into the specified directory.
![在这里插入图片描述](https://img-blog.csdnimg.cn/19ea37d37f3a42508663ebdc297d8004.png)

According to the vulnerability analysis, it is concluded that the core exploitation point of the vulnerability mainly depends on the `accountId` and the byte data passed in the POST request, so we can abstract the code that may be exploited.
```java
package com.example.sysaid;

import com.ilient.server.IlientConf;

import java.io.*;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import javax.servlet.annotation.*;

@WebServlet(name = "helloServlet", value = "/hello-servlet")
public class HelloServlet extends HttpServlet {
    private String message;

    public void init() {
    }

    public void doGet(HttpServletRequest var1, HttpServletResponse var2) throws IOException {
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse var2) throws ServletException, IOException {
        String accountId = request.getParameter("accountId");
        InflaterInputStream inputStream = new InflaterInputStream(request.getInputStream());
        byte[] bytes = InputStreamUtils.InputStreamToBytes(inputStream);
        String var46  = a(accountId);
        String var7 = request.getParameter("symbolName");
        File var31 = new File(var46 + File.separator + Long.toString(Calendar.getInstance().getTimeInMillis()) + ".zip");
        FileOutputStream var38;
        (var38 = new FileOutputStream(var31)).write(bytes);
        var38.flush();
        var38.close();
        // var46
        a(var31, var46, var7);
        if (!var31.delete()) {
            var31.setWritable(true);
            var31.delete();
        }
    }

    private static void a(File var0, String var1) {
        File var2;
        if ((var2 = new File(var1)).exists() && var2.isDirectory()) {
            File[] var6 = var2.listFiles();
            String var3 = Long.toString(Calendar.getInstance().getTimeInMillis()) + ".bad";
            File var5 = new File(var1, var3);
            if (var0.renameTo(var5)) {
                System.out.println("UserEntry.renameAndMoveFile: File renamed and moved successfully.");
            } else {
                System.out.println("UserEntry.renameAndMoveFile: Failed to rename and move the file.");
            }
            if (var6.length >= 10) {
                Arrays.sort(var6, Comparator.comparingLong(File::lastModified));
                for(int var4 = 0; var4 < var6.length - 9; ++var4) {
                    if (var6[var4].isFile() && !var6[var4].delete()) {
                        System.out.println("UserEntry.renameAndMoveFile: Failed to delete file: " + var6[var4].getName());
                    }
                }
            }
        } else {
            System.out.println("UserEntry.renameAndMoveFile: Invalid output folder specified.");
        }
    }

    private static void a(File var0, String var1, String var2) {
        if (!var2.startsWith("LDAP_REFRESH_")) {
            IlientConf.logger.error(String.format("Error on UserEntry: symboleName %s not validated.", var2));
            a(var0, var1);
        } else {
            byte[] var8 = new byte[1024];
            try {
                ZipInputStream var3;
                for(ZipEntry var4 = (var3 = new ZipInputStream(new FileInputStream(var0))).getNextEntry(); var4 != null; var4 = var3.getNextEntry()) {
                    String var9;
                    if ((var9 = var4.getName()) != null && var9.indexOf("..") >= 0) {
                        System.out.println("Error in UserEntry.unZipIt - Found path manipulation!");
                        a(var0, var1);
                        return;
                    }
                    File var10 = new File(var1 + File.separator + var9);
                    String var5 = (new File(var1)).getCanonicalPath();
                    System.out.println(var10.getCanonicalPath());
                    System.out.println(var5 + File.separator);
                    if (!var10.getCanonicalPath().startsWith(var5 + File.separator)) {
                        System.out.println("Error in UserEntry.unZipIt - File is outside of the output directory!");
                        a(var0, var1);
                        return;
                    }
                    System.out.println("File unzip : " + var10.getAbsoluteFile());
                    FileOutputStream var11 = new FileOutputStream(var10);
                    int var12;
                    while((var12 = var3.read(var8)) > 0) {
                        var11.write(var8, 0, var12);
                    }
                    var11.close();
                }
                var3.closeEntry();
                var3.close();
                System.out.println("Finish unziping: " + var0.getAbsolutePath());
            } catch (Exception var7) {
                var7.printStackTrace();
                System.err.println("UserEntry: Error in unZipIt method:"+ var7);
            }
        }
    }

    public static String a(String var0) {
//        String var1 = IlientConf.getInstance().getNonAccountSharedFilesDir("ldapfiles");
        String var1 = "/1111/SysAidServer/root/WEB-INF/ldapfiles";
        File var2;
        if (!(var2 = new File(var1 + File.separator + var0)).exists()) {
            var2.mkdirs();
        }
        return var1 + File.separator + var0;
    }

    public void destroy() {
    }
}
```


Build a new war project and deploy this Servlet to complete the simulation of vulnerability point units for dynamic debugging of vulnerabilities.
![](https://s3.bmp.ovh/imgs/2023/11/16/877a7a0cc8e7c7df.png)

# Summarize
Under special circumstances, vulnerability debugging and weaponized exploitation cannot meet the optimal debugging environment. We try to complete the dynamic debugging of the vulnerability by unit simulation of the vulnerable part of the code.

# Refer to
https://www.sysaid.com/blog/service-desk/on-premise-software-security-vulnerability-notification
https://www.huntress.com/blog/critical-vulnerability-sysaid-cve-2023-47246


<br/>

<br/>

[Goby Official URL](https://gobies.org/)

If you have a functional type of issue, you can raise an issue on GitHub or in the discussion group below:

1. GitHub issue: https://github.com/gobysec/Goby/issues
2. Telegram Group: http://t.me/gobies (Community advantage: Stay updated with the latest information about Goby features, events, and other announcements in real-time.) 
3. Telegram Channel: https://t.me/joinchat/ENkApMqOonRhZjFl 
4. Twitter：[https://twitter.com/GobySec](https://twitter.com/GobySec)
