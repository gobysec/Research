# 0x01前言
近期，Microsoft威胁情报团队曝光了DEV-0950（Lace Tempest）组织利用SysAid的事件。随后，SysAid安全团队迅速启动了应急响应，以应对该组织的攻击手法。然而，在对漏洞的分析和复现过程中，并未提供详细说明。由于该产品在安装时需要许可证，增加了动态调试漏洞的难度。为了便于调试能够快速复现该漏洞，我们尝试通过只使用部分的单元代码来模拟漏洞的主要逻辑流程进行动态调试分析。最终，我们成功利用 Goby 工具完美地实现了该漏洞的利用。
![在这里插入图片描述](https://img-blog.csdnimg.cn/65bbfcb45c7f4bbf91d8b6d944dcc0d1.gif#pic_center)

# 0x02 补丁分析
在 SysAid 中发布的公告中说明在 23.3.36 修复了该漏洞，通过 Diff 补丁发现该修复方式主要为限制 `com.ilient.server.UserEntry#doPost`函数中的 `..`来完成的。
![在这里插入图片描述](https://img-blog.csdnimg.cn/47ec9c6797c54dbc91f062c35ab28eb4.png)
# 0x03 单元调试
由于安装包在安装时对许可证进行了限制，因此无法有效地进行安装和调试。为了能够高效地进行动态调试，我们采取了以下优化策略：创建一个独立的空项目，将存在漏洞的 Servlet 进行重写，用于单元模拟。通过这种方法，我们可以在没有任何依赖的情况下最小化地运行漏洞点，并顺利完成研究和分析的工作。
通过修复的方式来推断，该漏洞通过目录穿越的方式来指定上传的路径（`accountId` 参数）以及上传内容来完成利用。
![在这里插入图片描述](https://img-blog.csdnimg.cn/f5ccce043c4b49a9939d362b519cd73d.png)

再收到 `accountId` 参数值后会通过 `a` 函数来完成对该路径的拼接，由于该拼接方式存在一定的问题就导致了目录穿越，然后将传入的数据流写入到 `accountId` 可控的路径。
![在这里插入图片描述](https://img-blog.csdnimg.cn/6e87594ba2874ec7a647f140046479e7.png)

在写入完毕之后通过调用 `a(var31, var46, var7);`完成对传入数据的解压到指定的目录中。
![在这里插入图片描述](https://img-blog.csdnimg.cn/19ea37d37f3a42508663ebdc297d8004.png)

根据漏洞分析得出漏洞的核心利用点主要取决于 `accountId` 和 POST 请求传入的字节数据，所以我们可以将存在可能利用的代码进行抽象。

```java
package com.example.sysaid;

import com.ilient.server.IlientConf;

import java.io.*;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Comparator;
import java.util.zip.InflaterInputStream;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import javax.servlet.ServletException;
import javax.servlet.http.*;
import javax.servlet.annotation.*;

@WebServlet(name = "helloServlet", value = "/hello-servlet")
public class HelloServlet extends HttpServlet {
    private String message;

    public void init() {
    }

    public void doGet(HttpServletRequest var1, HttpServletResponse var2) throws IOException {
    }

    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse var2) throws ServletException, IOException {
        String accountId = request.getParameter("accountId");
        InflaterInputStream inputStream = new InflaterInputStream(request.getInputStream());
        byte[] bytes = InputStreamUtils.InputStreamToBytes(inputStream);
        String var46  = a(accountId);
        String var7 = request.getParameter("symbolName");
        File var31 = new File(var46 + File.separator + Long.toString(Calendar.getInstance().getTimeInMillis()) + ".zip");
        FileOutputStream var38;
        (var38 = new FileOutputStream(var31)).write(bytes);
        var38.flush();
        var38.close();
        // var46
        a(var31, var46, var7);
        if (!var31.delete()) {
            var31.setWritable(true);
            var31.delete();
        }
    }

    private static void a(File var0, String var1) {
        File var2;
        if ((var2 = new File(var1)).exists() && var2.isDirectory()) {
            File[] var6 = var2.listFiles();
            String var3 = Long.toString(Calendar.getInstance().getTimeInMillis()) + ".bad";
            File var5 = new File(var1, var3);
            if (var0.renameTo(var5)) {
                System.out.println("UserEntry.renameAndMoveFile: File renamed and moved successfully.");
            } else {
                System.out.println("UserEntry.renameAndMoveFile: Failed to rename and move the file.");
            }
            if (var6.length >= 10) {
                Arrays.sort(var6, Comparator.comparingLong(File::lastModified));
                for(int var4 = 0; var4 < var6.length - 9; ++var4) {
                    if (var6[var4].isFile() && !var6[var4].delete()) {
                        System.out.println("UserEntry.renameAndMoveFile: Failed to delete file: " + var6[var4].getName());
                    }
                }
            }
        } else {
            System.out.println("UserEntry.renameAndMoveFile: Invalid output folder specified.");
        }
    }

    private static void a(File var0, String var1, String var2) {
        if (!var2.startsWith("LDAP_REFRESH_")) {
            IlientConf.logger.error(String.format("Error on UserEntry: symboleName %s not validated.", var2));
            a(var0, var1);
        } else {
            byte[] var8 = new byte[1024];
            try {
                ZipInputStream var3;
                for(ZipEntry var4 = (var3 = new ZipInputStream(new FileInputStream(var0))).getNextEntry(); var4 != null; var4 = var3.getNextEntry()) {
                    String var9;
                    if ((var9 = var4.getName()) != null && var9.indexOf("..") >= 0) {
                        System.out.println("Error in UserEntry.unZipIt - Found path manipulation!");
                        a(var0, var1);
                        return;
                    }
                    File var10 = new File(var1 + File.separator + var9);
                    String var5 = (new File(var1)).getCanonicalPath();
                    System.out.println(var10.getCanonicalPath());
                    System.out.println(var5 + File.separator);
                    if (!var10.getCanonicalPath().startsWith(var5 + File.separator)) {
                        System.out.println("Error in UserEntry.unZipIt - File is outside of the output directory!");
                        a(var0, var1);
                        return;
                    }
                    System.out.println("File unzip : " + var10.getAbsoluteFile());
                    FileOutputStream var11 = new FileOutputStream(var10);
                    int var12;
                    while((var12 = var3.read(var8)) > 0) {
                        var11.write(var8, 0, var12);
                    }
                    var11.close();
                }
                var3.closeEntry();
                var3.close();
                System.out.println("Finish unziping: " + var0.getAbsolutePath());
            } catch (Exception var7) {
                var7.printStackTrace();
                System.err.println("UserEntry: Error in unZipIt method:"+ var7);
            }
        }
    }

    public static String a(String var0) {
//        String var1 = IlientConf.getInstance().getNonAccountSharedFilesDir("ldapfiles");
        String var1 = "/1111/SysAidServer/root/WEB-INF/ldapfiles";
        File var2;
        if (!(var2 = new File(var1 + File.separator + var0)).exists()) {
            var2.mkdirs();
        }
        return var1 + File.separator + var0;
    }

    public void destroy() {
    }
}
```



构建新的 war 工程部署该 Servlet 即可完成对漏洞点单元模拟，用于漏洞的动态调试。
![在这里插入图片描述](https://img-blog.csdnimg.cn/7bfa1a55b4cb49aeb0b705808fbe9f30.png)


# 0x04 总结

在特殊情况下漏洞调试以及武器化利用时无法能够满足最佳的调试环境，我们尝试通过将有漏洞的部分代码进行单元模拟完成漏洞的动态调试。
# 0x05 参考
https://www.sysaid.com/blog/service-desk/on-premise-software-security-vulnerability-notification
https://www.huntress.com/blog/critical-vulnerability-sysaid-cve-2023-47246




Goby 官网: https://gobysec.net/
如果您有任何反馈建议，您可通过提交 issue 或是以下方式联系我们：
GitHub issue: https://github.com/gobysec/Goby/issues
微信群：关注公众号“GobySec“，回复暗号”加群“ （社群优势：可第一时间了解Goby功能发布、活动等咨询）
Telegram Group: http://t.me/gobies
推特：https://twitter.com/GobySec
